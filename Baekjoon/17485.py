'''
https://www.acmicpc.net/problem/17485
<문제>
- 최소한의 연료로 달에 도착하는 경로를 찾고 그때까지 소모한 연료를 출력하는 문제
- 우주선이 움직일 수 있는 경로는 3가지
  1. 대각선 왼쪽 아래, 2. 아래, 3. 대각선 오른쪽 아래
  ➤ 단, 우주선은 전에 움직인 방향과는 다른 방향으로 움직여야 한다.
    즉, 같은 방향으로 두번 연속 움직일 수 없다는 것이다.


<입력>
- 첫째 줄 : n, m (2 <= n, m <= 1000) - 행렬의 크기
- N개 줄 : m개의 행렬 원소 값(각 행렬의 원소값은 100 이하의 자연수)

<출력>
- 달 여행에 필요한 최소 연료의 값

<예제 입력>
6 4
5  8  5  1
3  5  8  4
9 77 65  5
2  1  5  2
5 98  1  5
4 95 67 58
- 최소 경로: 5 -> 5 -> 9 -> 1 -> 5 -> 4
  사용한 연료: 29
'''
####################
'''
<풀이 방향>
- 한쪽 루트로 진행하다가 다시 돌아오면서 다른 경로로 탐색하는 것을 반복
- DFS 알고리즘 사용(하려 했지만 O(1000 * 2^999))의 시간복잡도는 말이 안되므로 취소)
- 이전까지 이동한 최소 연료를 다시 사용하는 문제이므로 DP 알고리즘 사용
  - 우주선이 이동할 수 있는 방향은 [-1, -1], [0, -1], [1, -1]로 3가지.
  - dp[i][j][k] = 현 위치인 (i, j)에서 상위 행의 k방향에서의 최소 연료의 합 + 현위치 연료
        (여기서 k가 0이면 왼쪽 위, 1이면 가운데 위, 2이면 오른쪽 위)
          => 우주선은 2번 이상 동일한 방향으로 이동할 수 없으므로
            (k가 0일 때는 1, 2중에서 최솟값을 사용)
            (k가 1일 때는 0, 2중에서 최솟값을 사용)
            (k가 2일 때는 0, 1중에서 최솟값을 사용)
        
        🔴 이를 기반으로 한 점화식
        dp[i][j][0] = min(dp[i-1][j-1][1], dp[i-1][j-1][2]) + matrix[i][j]
        dp[i][j][1] = min(dp[i-1][j][0], dp[i-1][j+1][2]) + matrix[i][j]
        dp[i][j][2] = min(dp[i-1][j+1][0], dp[i-1][j+1][1]) + matrix[i][j]

∞	    0	           0	          0       	    0	     ∞
∞	[∞, 5,  5]	 [∞,    8,  8]	[5,   5,  5]	[1,  1,  ∞]	 ∞
∞	[∞, 8, 11]	 [10,  13, 10]	[16, 13,  9]	[9,  5,  ∞]	 ∞
∞	[∞, 20, 19]	 [85,  87, 90]	[75, 74, 70]	[14, 14, ∞]	 ∞
∞	[∞, 21, 22]  [20,  86, 75]	[92, 75, 19]	[72, 16, ∞]	 ∞
∞	[∞, 27, 25]	 [119,118,173] 	[76, 20, 17]	[24, 77, ∞]	 ∞
∞	[∞, 29, 122] [120,214,115]	[185,84, 91]	[75, 82, ∞]	 ∞
'''

import sys, math
input = sys.stdin.readline

inf = math.inf
# 1. 입력 받기
n, m = map(int, input().split())
matrix = [ list(map(int, input().split())) for _ in range(n)]

# 2. dp 리스트 만들기 - [[inf,inf,inf], [0,0,0], [0,0,0], [0,0,0], [0,0,0], [inf,inf,inf]] * (6+1)
dp = [ [[inf, inf, inf]] + [[0, 0, 0] for _ in range(m)] + [[inf, inf, inf]] for _ in range(n+1)] 
for i in range(1, n+1):
    for j in range(1, m+1):
        dp[i][j][0] = min(dp[i-1][j-1][1], dp[i-1][j-1][2]) + matrix[i-1][j-1]
        dp[i][j][1] = min(dp[i-1][j][0], dp[i-1][j][2]) + matrix[i-1][j-1]
        dp[i][j][2] = min(dp[i-1][j+1][0], dp[i-1][j+1][1]) + matrix[i-1][j-1]

# 3. 마지막 행의 최솟값 출력
min_fuel = inf
for i in dp[n][1:m+1]:
    temp = min(i)
    if min_fuel > temp:
        min_fuel = temp

print(min_fuel)