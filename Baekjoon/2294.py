'''
https://www.acmicpc.net/problem/2294
<문제>
- n개의 동전으로 k원 만들기
- 동전의 개수를 최소로 해야 함
  => DP 문제!
- 각 동전의 개수 제한은 없음

<입력>
- 첫째 줄 : n(1 <= n <= 100) - 동전의 가짓수
- 둘째 줄 : k(1 <= k <= 10,000) - 목표 금액

<출력>
- 사용할 동전의 최소 개수
- 불가능한 경우에는 -1 출력🔴

<예제 입력>
[동전 3개<1원, 5원, 12원>, 목표 금액: 15원]

- 점화식 : dp[i][j] = min(dp[i-1][j], dp[i][j-현재 동전 금액]+1)
    단, "i는 0부터 n까지, j는 0부터 k까지"이고 dp[0][0] = [0] + ( 10,001(k의 최댓값) * (k) )
       🟢 최솟값을 구하는 문제이므로 0번째 행의 0을 제외한 나머지 값을 "최댓값+1"로 설정하는 것이 포인트 🟢
  dp[i][j] : j를 만들기 위해 필요한 최소 동전의 수
  반복 범위 : range(1, n+1), 각 경우마다 range[i][현재 동전 금액]부터 range[i][k+1]까지 반복

  10,001 => ∞으로 나타낸 표
\	0	1	2	3	4	5	6	7	8	9	10	11	12	13	14	15
0	0	∞   ∞   ∞   ∞   ∞   ∞   ∞   ∞   ∞   ∞   ∞   ∞   ∞   ∞   ∞
1	0	1	2	3	4	5	6	7	8	9	10	11	12	13	14	15
5	0	1	2	3	4	1	2	3	4	5	2	3	4	5	6	3
12	0	1	2	3	4	1	2	3	4	5	2	3	1	2	3	3
'''

# 1. 입력 받기
n, k = map(int, input().split())
coins = [int(input()) for _ in range(n)]

# 2. dp
dp = [ [0] + [10001]*k ] * (n+1)
for i in range(1, n+1):
    dp[i] = dp[i-1].copy()
    coin = coins[i-1]
    for j in range(coin, k+1):
        dp[i][j] = min(dp[i-1][j], dp[i][j-coin] + 1)

# 3. 출력
print(dp[n][k]) if dp[n][k] != 10001 else print(-1)